{"version":3,"sources":["../src/websocket-client.js"],"names":["delay","Promise","setTimeout","resolve","ms","ConnectionError","BaseError","AbortedConnection","CLOSED","CONNECTING","MESSAGE","OPEN","WebSocketClient","url","protocols","opts","_url","rejectUnauthorized","_opts","_protocols","_protocol","_socket","_status","_onClose","bind","status","socket","abort","close","promise","backoff","_open","iterator","Symbol","cancelled","cancel","error_","attempt","catch","current","error","next","done","value","emit","then","data","_assertStatus","send","notExpected","expected","previous","WebSocket","eventToPromise","multi","addEventListener","args","message","EventEmitter"],"mappings":"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","file":"websocket-client.js","sourcesContent":["import eventToPromise from 'event-to-promise'\nimport startsWith from 'lodash/startsWith'\nimport WebSocket from 'isomorphic-ws'\nimport { attempt } from 'promise-toolbox'\nimport { BaseError } from 'make-error'\nimport { EventEmitter } from 'events'\n\n// ===================================================================\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms))\n\n// ===================================================================\n\n// This error is used to fail pending requests when the connection is\n// closed.\nexport class ConnectionError extends BaseError {}\n\nexport class AbortedConnection extends ConnectionError {\n  constructor () {\n    super('connection aborted')\n  }\n}\n\n// -------------------------------------------------------------------\n\nexport const CLOSED = 'closed'\nexport const CONNECTING = 'connecting'\nexport const MESSAGE = 'message'\nexport const OPEN = 'open'\n\n// -------------------------------------------------------------------\n\nexport default class WebSocketClient extends EventEmitter {\n  constructor (url, protocols, opts) {\n    super()\n\n    if (opts && !startsWith(this._url, 'wss')) {\n      // `rejectUnauthorized` cannot be used if the connection is not\n      // `secure!\n      delete opts.rejectUnauthorized\n    }\n\n    this._opts = opts\n    this._protocols = protocols\n    this._url = url\n\n    this._protocol = null\n    this._socket = null\n    this._status = CLOSED\n\n    this._onClose = this._onClose.bind(this)\n  }\n\n  get protocol () {\n    return this._protocol\n  }\n\n  get status () {\n    return this._status\n  }\n\n  close () {\n    return attempt(() => {\n      const status = this._status\n      if (status === CLOSED) {\n        return\n      }\n\n      const socket = this._socket\n      if (status === CONNECTING) {\n        socket.abort = true\n        socket.close()\n        return\n      }\n\n      const promise = eventToPromise(socket, 'close')\n      socket.close()\n      return promise\n    })\n  }\n\n  open (backoff) {\n    if (!backoff) {\n      return this._open()\n    }\n\n    const iterator = backoff[Symbol.iterator]()\n\n    let cancelled = false\n    const cancel = () => {\n      cancelled = true\n    }\n\n    let error_\n    const attempt = () => {\n      if (cancelled) {\n        throw error_\n      }\n\n      return this._open().catch(error => {\n        let current\n\n        if (\n          error instanceof AbortedConnection ||\n          (current = iterator.next()).done\n        ) {\n          throw error\n        }\n\n        const { value } = current\n        this.emit('scheduledAttempt', {\n          cancel,\n          delay: value,\n        })\n\n        error_ = error\n        return delay(current.value).then(attempt)\n      })\n    }\n\n    const promise = attempt()\n    promise.cancel = cancel\n\n    return promise\n  }\n\n  send (data) {\n    this._assertStatus(OPEN)\n\n    this._socket.send(data)\n  }\n\n  _assertNotStatus (notExpected) {\n    if (this._status === notExpected) {\n      throw new ConnectionError(`invalid status ${this._status}`)\n    }\n  }\n\n  _assertStatus (expected) {\n    if (this._status !== expected) {\n      throw new ConnectionError(`invalid status ${this._status}, expected ${expected}`)\n    }\n  }\n\n  _onClose () {\n    const previous = this._status\n\n    this._socket = null\n    this._status = CLOSED\n\n    if (previous === OPEN) {\n      this.emit(CLOSED)\n    }\n  }\n\n  _open () {\n    return attempt(() => {\n      this._assertStatus(CLOSED)\n      this._status = CONNECTING\n\n      const socket = this._socket = new WebSocket(\n        this._url,\n        this._protocols,\n        this._opts\n      )\n\n      return eventToPromise.multi(\n        socket,\n        [ 'open' ],\n        [ 'close', 'error' ]\n      ).then(\n        () => {\n          socket.addEventListener('close', this._onClose)\n\n          socket.addEventListener('error', error => {\n            this.emit('error', error)\n          })\n\n          socket.addEventListener('message', ({ data }) => {\n            this.emit(MESSAGE, data)\n          })\n\n          this._status = OPEN\n          this.emit(OPEN)\n        },\n        args => {\n          this._onClose()\n\n          if (socket.abort) {\n            throw new AbortedConnection()\n          }\n\n          throw new ConnectionError(args[0].message)\n        }\n      )\n    })\n  }\n}\n"]}